并发控制
========
并发控制保证并发事务的**隔离性和一致性**。  
并发控制以事务为单位，通常使用封锁技术实现并发控制。  
两段锁协议是可串行化调度的充分条件，不是必要条件。
>###并发与并行
要完成吃完三个馒头的任务：
- 一个人可以这个馒头咬一口，那个馒头咬一口，这样交替进行，最后吃完三个馒头，这就是并发。
- 三个馒头如果分给三个人吃，这样的任务完成形式叫并行。

##并发控制带来的不一致性
有三种：
- 丢失修改
- 不可重复读
- 读“脏”数据

##封锁
基本的封锁类型有两种：

|封锁|别名|描述
|-----|----|-----
|排它锁|写锁、X锁|若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。
|共享锁|读锁、S锁|若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务职能再对A加S锁，而不能加X锁，直到T释放A上S锁。

可以用相容矩阵来表示X锁和S锁的关系

|T`1` \ T`2`|X|S|-
|:---------:|:---:|:---:|:---:
|**X**|No|No|Yes
|**S**|No|Yes|Yes
|**-**|Yes|Yes|Yes
最左边一列表示T`1`已经获得数据对象上锁的类型。  
最上面一行表示T`2`对同一数据对象发送的封锁请求。  
其中`-`表示没有加锁。
##活锁与死锁
详情参考[活锁与死锁](活锁与死锁.md)
##并发调度的可串行性
DBMS对并发事务不同的调度可能会产生不同的结果。  
显然，只有串行调度是正确的，执行结果等价于串行调度的调度也是正确的。这样的调度称为**可串行化调度**。
###可串行化调度
多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略是**可串行化调度**。
>**可串行性**是并发事务正确执行的准则。  
一个给定的并发调度，当且仅当它是可串行化的，才认为是**争取调度**。

###冲突可串行化调度
|概念术语|定义|
|-------|-----|
|**冲突操作**|是指不同的事务对同一个数据的读写操作和写写操作；其他的都开始**不冲突操作**。
|**冲突可串行化调度**|一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc'是可串行的，称Sc为冲突可串行化调度。

冲突的可串行化调度室可串行化调度的**充分条件**，不是必要条件。